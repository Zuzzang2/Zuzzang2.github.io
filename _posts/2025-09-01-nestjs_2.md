---
title: NestJS 인증 흐름 뜯어보기 – AuthGuard, JWT, 전략 패턴까지
date: 2025-09-01 15:00:00 +09:00
categories: [Framework, Nest.js]
tags:
  [Nest.js, jwt, passport, guard, strategy, 인증인가, 백엔드보안, typescript]
  
---


## 시작하기에 앞서

NestJS에서 JWT 인증을 직접 구현해본 경험을 정리하기 위해 작성해보려고 한다.<br>
특히 토큰 발급과 가드(Guard), 그리고 JwtStrategy의 동작 과정을 실제 코드와 함께 정리하면서,<br>
NestJS의 인증 흐름을 더 명확히 이해하는 것이 목표이다.

<br> 


---

## 1. 가드(Guard)란?

가드는 컨트롤러 앞에서 요청을 검사하는 보안 관문이다.<br>
요청이 컨트롤러에 도달하기 전에 실행되어, 인증·인가 같은 보안 로직을 처리하고 안전하지 않은 요청은 차단한다.<br>
Express의 미들웨어와 비슷하지만, 가드는 `컨트롤러 실행 여부 자체를 결정`한다는 점에서 보안에 더 특화되어 있다.

<br> 

---

## 2. 직접 구현한 코드 설명

### 1. 토큰 발급 코드

```ts
// auth.service.ts

async signin(@Body() dto: SignInDto) {
  // ... 사용자 검증
  const payload = { sub: user.id, email: user.email };
  const accessToken = this.jwt.sign(payload, { expiresIn: '1h' });
  return { accessToken };
}

```

### 2. AuthGuard('jwt') 사용
```ts
@UseGuards(AuthGuard('jwt'))
@Get('me')
getProfile(@Request() req) {
  return req.user;
}
```
보통은 AuthGuard('jwt')를 바로 쓰기보다 JwtAuthGuard라는 클래스로 래핑해서 재사용한다.


### 3. JwtStrategy 내부
```ts
@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private config: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: config.get<string>('JWT_SECRET'),
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, email: payload.email };
  }
}
```
super()의 역할 <br>
→ 토큰을 어디서 추출할지, 어떤 키로 서명 검증할지를 정의한다.

<br>

---

## 3. 실제 흐름 요약
1. 클라이언트가 /signin에서 JWT 토큰 발급받음.

2. 이후 요청 시 Authorization: Bearer <token> 헤더를 붙여서 보냄.

3. AuthGuard('jwt') 실행 → 내부적으로 JwtStrategy 동작.

4. JwtStrategy의 validate() 호출 → 결과를 req.user에 저장.

5. 컨트롤러에서 인증된 사용자 정보(req.user) 사용 가능.

---

## 결론
NestJS에서 JWT 인증을 구현하면서, 가드와 전략이 어떻게 맞물려 작동하는지 구조를 제대로 이해할 수 있었다.<br>
단순한 로그인 인증을 넘어서, Role에 따른 접근 제어나 커스텀 가드도 직접 만들어보며 확장해봐야겠다.

<br> 

